# "Hello World" using the Cert Zero Copy Transport

This repo provides an example publication and subscription pair of applications to send and receive a simple user-defined `HelloWorld` type. This example uses Dynamic Participant Static Endpoint (DPSE) discovery over a statically configured UDP transport. User data is communicated over Shared Memory using the Zero Copy Transport. 

## Purpose

This example shows how to perform basic publish-subscribe communication using Zero Copy. For convenience, complete source code and a sample `CmakeLists.txt` (for Linux) has been provided. 

## Source Overview

A simple `HelloWorld` type, containing an array member, is defined in `HelloWorld.idl`. Note that the idl is annotated with `@SHMEM_REF`.

For the type to be useable by Connext Cert, type-support files must be generated that implement a type-plugin interface.  These support files are generated by invoking `rtiddsgen` and passing it the specific idl file. `rtiddsgen` can be invoked manually with the following command:

    ${RTIMEHOME}/rtiddsgen/scripts/rtiddsgen -micro -language C HelloWorld.idl

The generated source files are `HelloWorld.c`, `HelloWorldSupport.c`, and `HelloWorldPlugin.c`.  Associated header files are also generated.
 
The DataWriter and DataReader of the type are managed in `HelloWorld_publisher.c` and `HelloWorld_subscriber.c`, respectively.  The DomainParticipant of each is managed in `HelloWorldApplication.c`.  
  
## Example Files Overview


### HelloWorldApplication.c:
This file contains the logic for creating an application.  This includes steps for configuring discovery and creating a DomainParticipant. This file also includes code for registering a type with the DomainParticipant.

This file also statically configures the UDP interface with a single loopback interface with the name "lo". Please look at lines 139 - 201 for details on how to manually configure which interfaces are available. The example configures a single loopback interface.

This file then initializes the ZeroCopy transports. This is done in lines 203 - 216.
 
### HelloWorld_publisher.c:
This file contains the logic for creating a Publisher and a DataWriter, and sending data.

### HelloWorld_subscriber.c:
This file contains the logic for creating a Subscriber and a DataReader, a DataReaderListener, and listening for data.

### HelloWorldPlugin.c:
This file creates the plugin for the HelloWorld data type.  This file contains the code for serializing and deserializing the HelloWorld type; creating, copying, printing and deleting the HelloWorld type; determining the size of the serialized type, and handling hashing a key; and creating the plug-in. With the SHMEM_REF included in the idl, it also includes a function to help and manage the pool of samples in the shared memory. 

### HelloWorldSupport.c
This file defines the HelloWorld type and its typed DataWriter, DataReader, and Sequence.

### HelloWorld.c
This file contains the APIs for managing the HelloWorld type.


## Compiling And Running The Example Applications

Before compiling, make sure of the following:
- The desired version of compiler and linker is in your `PATH` environment variable.
- The environment variable `RTIMEHOME` is defined and that it points to Connext Micro installation directory. 
- The `RTIMEARCH` environment variable is set to the appropriate architecture: either `x64Linux4gcc7.3.0CERT` or `armv8QOS2.2qcc_gpp8.3.0CERT` for the current release.

### Compiling For Linux

    cd <your project directory>
    ${RTIMEHOME}/resource/scripts/rtime-make --target ${RTIMEARCH} -G "Unix Makefiles" --build -DRTIME_CERT=1 --config Release --source-dir . --delete

### Compiling For QNX

    cd <your project directory>
    gmake

### Running The Example

Run the subscriber by typing:

    ./objs/${RTIMEARCH}/HelloWorld_subscriber -domain <Domain_ID> 

and run the publisher by typing:

    ./objs/${RTIMEARCH}/HelloWorld_publisher -domain <Domain_ID>

**NOTE**: The publisher waits for an user input (Enter Key) after creation to start sending samples.